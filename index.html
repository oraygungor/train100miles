<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Train Paradox: Visual Proof</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #2563EB;
            margin-top: -8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #E5E7EB;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Minimal Header -->
    <div class="text-center mb-8">
        <h1 class="text-4xl font-bold text-slate-900 tracking-tight mb-2">The Train Paradox</h1>
        <p class="text-slate-500 text-sm">Condition: <span class="font-semibold text-red-500">Every</span> 1-hour interval covers exactly 100 miles.</p>
    </div>

    <!-- Main Card -->
    <div class="bg-white p-4 rounded-3xl shadow-xl border border-slate-100 max-w-5xl w-full">
        
        <!-- Canvas Wrapper (Increased Height for 2 Graphs) -->
        <div class="relative w-full aspect-[9/10] md:aspect-[16/10] lg:h-[650px]">
            <canvas id="trainChart" class="w-full h-full rounded-2xl"></canvas>
            
            <!-- Minimal Legend (Right Side) -->
            <div class="absolute top-60 right-20 bg-white/90 backdrop-blur text-xs p-3 rounded-lg border border-slate-100 shadow-sm flex flex-col gap-2">
                <div class="flex items-center gap-2">
                    <span class="w-2.5 h-2.5 rounded-full bg-blue-600"></span> 
                    <span class="font-medium text-slate-600">Actual Path</span>
                </div>
                <div class="flex items-center gap-2">
                    <span class="w-2.5 h-2.5 rounded-full bg-red-500"></span> 
                    <span class="font-medium text-slate-600">Total Avg Speed</span>
                </div>
            </div>
        </div>

        <!-- Single Control: Speed Variance -->
        <div class="px-8 py-6 border-t border-slate-50 mt-2">
            <div class="flex justify-between items-center mb-4">
                <span class="font-bold text-slate-700">Speed Variance</span>
                <span id="varianceVal" class="font-mono text-lg text-blue-600 font-bold">0%</span>
            </div>
            
            <input type="range" id="varianceSlider" min="-100" max="100" value="0" step="1">
            
            <div class="flex justify-between text-xs text-slate-400 mt-3 font-medium tracking-wide uppercase">
                <span>Constant Speed</span>
                <span>Variable Speed</span>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('trainChart');
        const ctx = canvas.getContext('2d');
        const varianceSlider = document.getElementById('varianceSlider');
        const varianceVal = document.getElementById('varianceVal');

        // Logic Setup
        let sliderValue = 0;
        let scannerT = 0; 
        
        // Resize canvas for crisp rendering
        function resize() {
            canvas.width = canvas.parentElement.offsetWidth * 2;
            canvas.height = canvas.parentElement.offsetHeight * 2;
            ctx.scale(2, 2);
        }
        window.addEventListener('resize', resize);
        resize();

        // Math Constants
        const margin = { top: 40, right: 40, bottom: 30, left: 60 }; 
        const maxTime = 5.5; 
        const maxDist = 600; 

        // Physics Functions
        function getAmplitude() { return sliderValue * 0.98; }

        function getDistance(t) {
            const A = getAmplitude();
            const term = (A / (2 * Math.PI)); 
            return 100 * t + term * (1 - Math.cos(2 * Math.PI * t));
        }

        function getVelocity(t) {
            const A = getAmplitude();
            return 100 + A * Math.sin(2 * Math.PI * t);
        }

        // Draw Loop
        function draw() {
            const w = canvas.width / 2;
            const h = canvas.height / 2;
            ctx.clearRect(0, 0, w, h);

            // --- LAYOUT DEFINITIONS ---
            // Distance Graph: Top 60%
            const hDist = h * 0.60; 
            const bottomDist = hDist; 
            
            // Velocity Graph: Bottom 25% (with some gap)
            const hVel = h * 0.25; 
            const topVel = h * 0.70; // Starts at 70% height
            const bottomVel = topVel + hVel;

            // --- 1. DISTANCE GRAPH ---
            const scaleX = (t) => margin.left + (t / maxTime) * (w - margin.left - margin.right);
            const scaleY_Dist = (d) => bottomDist - margin.bottom - (d / maxDist) * (hDist - margin.top - margin.bottom);

            // Distance Grid X
            ctx.strokeStyle = '#F1F5F9';
            ctx.lineWidth = 1;
            ctx.font = '11px Inter';
            ctx.fillStyle = '#94A3B8';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let t = 0; t <= 5; t++) {
                const x = scaleX(t);
                ctx.beginPath(); ctx.moveTo(x, margin.top); ctx.lineTo(x, bottomDist - margin.bottom); ctx.stroke();
                // Label only on bottom graph X axis generally, but let's put small labels here too
                // ctx.fillText(t + 'h', x, bottomDist - margin.bottom + 15);
            }
            // 5.5h Mark
            const xFinal = scaleX(5.5);
            ctx.beginPath(); ctx.moveTo(xFinal, margin.top); ctx.lineTo(xFinal, bottomDist - margin.bottom); ctx.stroke();

            // Distance Grid Y
            ctx.textAlign = 'right';
            for (let d = 0; d <= maxDist; d += 100) {
                const y = scaleY_Dist(d);
                ctx.beginPath(); ctx.moveTo(margin.left, y); ctx.lineTo(w - margin.right, y); ctx.stroke();
                ctx.fillText(d, margin.left - 12, y);
            }

            // Distance Label
            ctx.save();
            ctx.translate(20, hDist / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#64748B';
            ctx.font = 'bold 12px Inter';
            ctx.fillText("Distance (miles)", 0, 0);
            ctx.restore();

            // Avg Speed Line (Red - Dashed)
            const tTotal = 5.5;
            const dTotal = getDistance(tTotal);
            ctx.beginPath();
            ctx.strokeStyle = '#EF4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.moveTo(scaleX(0), scaleY_Dist(0));
            ctx.lineTo(scaleX(tTotal), scaleY_Dist(dTotal));
            ctx.stroke();
            ctx.setLineDash([]);

            // Distance Markers
            const xFinalMark = scaleX(tTotal);
            const yFinalMark = scaleY_Dist(dTotal);
            ctx.beginPath();
            ctx.strokeStyle = '#DC2626'; 
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.moveTo(xFinalMark, yFinalMark); ctx.lineTo(margin.left, yFinalMark);
            ctx.moveTo(xFinalMark, yFinalMark); ctx.lineTo(xFinalMark, bottomDist - margin.bottom);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.beginPath(); ctx.fillStyle = '#DC2626'; ctx.arc(xFinalMark, yFinalMark, 4, 0, Math.PI * 2); ctx.fill();

            // Total Distance Label
            ctx.save();
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const text = dTotal.toFixed(1);
            const textWidth = ctx.measureText(text).width;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)'; 
            ctx.fillRect(margin.left - 18 - textWidth, yFinalMark - 10, textWidth + 14, 20);
            ctx.fillStyle = '#DC2626'; 
            ctx.fillText(text, margin.left - 12, yFinalMark);
            ctx.restore();

            // Actual Curve (Blue) - Distance
            ctx.beginPath();
            ctx.strokeStyle = '#2563EB'; 
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            for (let px = margin.left; px <= w - margin.right; px++) {
                const t = (px - margin.left) / (w - margin.left - margin.right) * maxTime;
                if (t > maxTime) break;
                const d = getDistance(t);
                if (px === margin.left) ctx.moveTo(px, scaleY_Dist(d));
                else ctx.lineTo(px, scaleY_Dist(d));
            }
            ctx.stroke();

            // --- 2. VELOCITY GRAPH ---
            // Y Scale for Velocity (0 to 200 mph)
            const scaleY_Vel = (v) => bottomVel - (v / 200) * hVel;

            // Velocity Grid
            ctx.strokeStyle = '#E2E8F0';
            ctx.fillStyle = '#94A3B8';
            ctx.textAlign = 'right';
            
            // X Axis ticks for Velocity
            ctx.textAlign = 'center';
            for (let t = 0; t <= 5; t++) {
                const x = scaleX(t);
                ctx.beginPath(); ctx.moveTo(x, topVel); ctx.lineTo(x, bottomVel); ctx.stroke();
                ctx.fillText(t + 'h', x, bottomVel + 20);
            }
            const xFinalV = scaleX(5.5);
            ctx.beginPath(); ctx.moveTo(xFinalV, topVel); ctx.lineTo(xFinalV, bottomVel); ctx.stroke();
            ctx.fillText('5.5h', xFinalV, bottomVel + 20);

            // Y Axis for Velocity (0, 100, 200)
            ctx.textAlign = 'right';
            [0, 100, 200].forEach(v => {
                const y = scaleY_Vel(v);
                ctx.beginPath(); 
                if (v === 100) {
                    ctx.strokeStyle = '#94A3B8'; ctx.setLineDash([4,4]); // Reference line
                } else {
                    ctx.strokeStyle = '#E2E8F0'; ctx.setLineDash([]);
                }
                ctx.moveTo(margin.left, y); ctx.lineTo(w - margin.right, y); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillText(v, margin.left - 12, y);
            });

            // Velocity Label
            ctx.save();
            ctx.translate(20, topVel + hVel / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#64748B';
            ctx.font = 'bold 12px Inter';
            ctx.fillText("Velocity (mph)", 0, 0);
            ctx.restore();

            // Velocity Curve (Blue)
            ctx.beginPath();
            ctx.strokeStyle = '#2563EB'; 
            ctx.lineWidth = 2;
            for (let px = margin.left; px <= w - margin.right; px++) {
                const t = (px - margin.left) / (w - margin.left - margin.right) * maxTime;
                if (t > maxTime) break;
                const v = getVelocity(t);
                if (px === margin.left) ctx.moveTo(px, scaleY_Vel(v));
                else ctx.lineTo(px, scaleY_Vel(v));
            }
            ctx.stroke();

            // --- SCANNER LOGIC (Both Graphs) ---
            const tStart = scannerT;
            const tEnd = scannerT + 1;
            
            if (tEnd <= maxTime + 0.1) {
                // A. Distance Scanner
                const xS = scaleX(tStart);
                const xE = scaleX(tEnd);
                const yS = scaleY_Dist(getDistance(tStart));
                const yE = scaleY_Dist(getDistance(tEnd)); 

                // Fill Box
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)'; 
                ctx.strokeStyle = '#10B981'; 
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(xS, yS); ctx.lineTo(xE, yS); ctx.lineTo(xE, yE); ctx.lineTo(xS, yE); ctx.lineTo(xS, yS); ctx.fill(); ctx.stroke();

                // Labels
                ctx.fillStyle = '#059669'; ctx.font = 'bold 10px Inter'; ctx.textAlign = 'left';
                ctx.fillText("Î”d=100", xE + 6, (yS+yE)/2);

                // Train Dot (Distance)
                ctx.beginPath(); ctx.fillStyle = '#2563EB'; ctx.arc(xS, yS, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();

                // Dynamic Labels (Scanner)
                const v = getVelocity(tStart);
                const totalAvg = dTotal / tTotal;
                const centerX = (xS + xE) / 2;

                ctx.save(); ctx.fillStyle = '#2563EB'; ctx.font = 'bold 13px Inter'; ctx.textAlign = 'center';
                ctx.fillText(`v = ${v.toFixed(0)} mph`, centerX, yE - 12); 
                ctx.restore();

                ctx.save(); ctx.fillStyle = '#DC2626'; ctx.font = 'bold 13px Inter'; ctx.textAlign = 'center';
                ctx.fillText(`Total Avg: ${totalAvg.toFixed(1)} mph`, centerX, yS + 20); 
                ctx.restore();

                // B. Velocity Marker
                // Shows the current velocity on the bottom graph
                const yV = scaleY_Vel(v);
                
                // Vertical Line connecting graphs
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(37, 99, 235, 0.2)'; // Faint blue line
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.moveTo(xS, yS + 6); // From top dot
                ctx.lineTo(xS, yV);     // To bottom dot
                ctx.stroke();
                ctx.setLineDash([]);

                // Velocity Dot
                ctx.beginPath();
                ctx.fillStyle = '#2563EB'; // Blue
                ctx.arc(xS, yV, 4, 0, Math.PI*2);
                ctx.fill();
                
                // Velocity Text (Small)
                ctx.fillStyle = '#2563EB';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(v.toFixed(0), xS, yV - 8);
            }
        }

        function loop() {
            scannerT += 0.005;
            if (scannerT > 4.5) scannerT = 0;
            draw();
            requestAnimationFrame(loop);
        }

        varianceSlider.addEventListener('input', (e) => {
            sliderValue = parseFloat(e.target.value);
            varianceVal.innerText = Math.abs(sliderValue) + "%";
        });

        loop();

    </script>
</body>
</html>
